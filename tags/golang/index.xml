<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on blog &lt;- takecy</title>
    <link>https://takecy.github.io/tags/golang/</link>
    <description>Recent content in Golang on blog &lt;- takecy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; &lt;a href=&#34;https://github.com/takecy&#34;&gt;takecy&lt;/a&gt; 2018</copyright>
    <lastBuildDate>Sat, 24 Oct 2015 23:18:26 +0900</lastBuildDate>
    
	<atom:link href="https://takecy.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>UbuntuにGoをインストールしたDokcerイメージを作る</title>
      <link>https://takecy.github.io/posts/golang-docker-ubuntu-install/</link>
      <pubDate>Sat, 24 Oct 2015 23:18:26 +0900</pubDate>
      
      <guid>https://takecy.github.io/posts/golang-docker-ubuntu-install/</guid>
      <description>Dokcernizeってますか？ 最近やっとちょっとだけDockerさんに話しかけたりしています。
UbuntuにGo入れたイメージを作るDokcerfileの大事なところはこんなです。
RUN wget https://storage.googleapis.com/golang/go1.5.1.linux-amd64.tar.gz RUN tar -C /usr/local -xf go1.5.1.linux-amd64.tar.gz ENV PATH=$PATH:/usr/local/go/bin ENV GOPATH=$HOME/go ENV PATH=$GOPATH/bin:$PATH   よかったらどうぞ。
Ubuntu Golang
 今まで主にVagrantでローカル開発環境を作ってきたのだけど、Dockerってすごいね。。(遅)
何より、「捨てやすい」のが素晴らしい。使い捨て。さっと起動してさっと動かしてさっと捨てる 。イミュータブル！
一方、Vagrantはそれはそれで、sshしてhogehogeって感じがサーバいじるのと似ててとっつきやすい。 クラウド()になって、 sshしてあれこれインストールしてサーバ設定というのはもうなくなっちゃったよね。
最近は、サーバ設定(というかインスタンス設定)はTerraformだし、ルーチン処理やリリースはAnsibleだし。 かといって、sshも必要で、shellスクリプトは前より書くようになったんじゃないかと思うくらいだし。
自分の場合、一応アプリケーションエンジニアというくくりになるのだけど、 こんなにインフラ寄りの作業をやっていることにふと気づいて驚いている。
今後もっと、アプリの人はインフラの知識を、インフラの人はアプリの知識をな感じで、 近づいていくんだろうか。
システム開発における、エンジニア一人の担当範囲が広くなっていってる感じ。
なんて面白い時代だ。</description>
    </item>
    
    <item>
      <title>Goとマイクロサービス</title>
      <link>https://takecy.github.io/posts/golang-microservice/</link>
      <pubDate>Sun, 04 Oct 2015 22:29:08 +0900</pubDate>
      
      <guid>https://takecy.github.io/posts/golang-microservice/</guid>
      <description>マイクロサービスの定義としては
「あるサービスが、独立した小さなサービスの集合で構成される」
というのが一般的？で、俺もそう思っている。
Goはこのマイクロサービス的なサービス開発に適している気がする。

ワンバイナリ=サービスの単位 Goの最大のメリットと考えているのは、
ビルドしたら実行可能なバイナリが1個吐き出されて、ミドルウェア等の設定が不要。
というのは、過去にも書いた。
この実行可能なバイナリをマイクロサービスでいうところの「小さなサービス」とすると、とてもしっくり来る感じ。

バイナリ=Goパッケージ=サーバインスタンスの単位  API Batch A Batch B Proxy(image)  で構成されるサービスがあったとして、全部Goで書いたとする。
それぞれがGoプロジェクトの1パッケージに対応し、そのパッケージ毎にバイナリを生成し、 バイナリごとにサーバインスタンスを割り当てる感じになる。
まさにマイクロサービス。

まとめ GoはProxyサーバみたいな特定の用途に特化した(アドホックな)処理を、 1個のバイナリとしてまとめられるので、Goで全部やってると勝手にマイクロサービスっぽくなるよね
というお話。</description>
    </item>
    
    <item>
      <title>Goのいいとこ悪いとこを1個づつあげる</title>
      <link>https://takecy.github.io/posts/golang-good-bad/</link>
      <pubDate>Wed, 16 Sep 2015 22:54:02 +0900</pubDate>
      
      <guid>https://takecy.github.io/posts/golang-good-bad/</guid>
      <description>Goのいいところ悪いところをそれぞれ1個だけ挙げてみる。
いいところ デプロイが簡単 もはやこれだけで、Goを使う価値があるといっていいほど。
go build からの、サーバへscp
以上終わり。
これはすごい。。サーバ側は一切の設定、ミドルのインストールがいらない。
nodeやJDKなどの実行環境が不要。すごい。
(実際にはnginxやプロセスを管理するsupervisor的なものが必要だけど)
よく言われる、Goのメリットだけど、本当にすごい。
ビルドしたら実行可能な単一のバイナリが吐きだされる。プラットフォームごとに。
この点の別のメリットとして、Go自体ののバージョンアップが簡単というのがある。
最近1.5.1に上がったけど、ビルド後のバイナリとして正しく動いていれば、サーバ側はなんの変更もいらない。 バイナリを差し替えるだけ。
nodeやJDKだと、バージョンアップは大仕事だけど、Go簡単すぎ。すごい。

悪いところ 型が中途半端 これもよく言われているけど、型システム微妙。
これの最大の弊害は抽象化のしづらさにある。
色んなライブラリを見たつもりだけど、結構出てくるのが
interface{} map[string]interface{}
が引数、戻り値。
型意味ねえ。
Goは静的型付け言語に分類されるが、抽象化しづらいので結局「何でも入る型」を使っちゃって、 コンパイラの恩恵が少ない。
ジェネリクスはよ。。&amp;gt;&amp;lt;

まとめ 悪いところもあるけれど、「デプロイが簡単」「バージョンアップが簡単」のメリットを捨てるほどではない。
という結論に今のところなっている感じ。</description>
    </item>
    
    <item>
      <title>Go言語でループ</title>
      <link>https://takecy.github.io/posts/golang-loop/</link>
      <pubDate>Sun, 30 Aug 2015 19:51:31 +0900</pubDate>
      
      <guid>https://takecy.github.io/posts/golang-loop/</guid>
      <description>今でもたまにやらかすのでメモっておく。
①
users := []string{&amp;quot;take&amp;quot;, &amp;quot;hoge&amp;quot;, &amp;quot;moge&amp;quot;} for i := range users { fmt.Println(users[i]) // i is index }  ②
users := []string{&amp;quot;take&amp;quot;, &amp;quot;hoge&amp;quot;, &amp;quot;moge&amp;quot;} for i, user := range users { fmt.Println(user) // user is value copy }  ③
users := []string{&amp;quot;take&amp;quot;, &amp;quot;hoge&amp;quot;, &amp;quot;moge&amp;quot;} for _, user := range users { fmt.Println(user) // user is value copy }  ①が一番早い。 でも②③の方が読みやすい。</description>
    </item>
    
    <item>
      <title>Go言語の依存パッケージ管理の闇</title>
      <link>https://takecy.github.io/posts/golang-package-godep/</link>
      <pubDate>Sun, 16 Aug 2015 23:17:30 +0900</pubDate>
      
      <guid>https://takecy.github.io/posts/golang-package-godep/</guid>
      <description>複数人で開発している場合、各メンバーのローカル環境が揃っていることは重要なこと。
OSや言語のランタイムのバージョンはもちろんだけど、 依存しているパッケージのバージョンを同じにしておくことは重要。
俺はテスト通ってるけどTravisさんでは通らないとかマジいらっとするし、 バグった時の再現性とかもろもろ問題が出てくるので、環境の同期は重要。
例えば、JavaではMaven+pom.xmlやGradle+build.gradle、Nodeならnpm+package.jsonなところを、 Goではどうやるんだっていう話。

Goで依存パッケージを取得する  go get github.com/google/go-github/github  以上。
簡単。これは捗る！
と思いきや、実際の開発ではいろいろ問題が発生する。

バージョンいくつなんだよ問題 Goは、パッケージ取得の仕組み(go get hoge/hoge のこと)は言語レベルで存在するが、 パッケージの列挙とバージョンを管理する仕組みは存在しない。
「このプロジェクトで使われているパッケージはA(ver0.9)とB(ver1.2)である。」
というのを表現する方法は無い。
よって各メンバーが、README等をみながら、
go get A go get B go get C ...  をぽちぽちやらなくてはいけない。
また、go get したタイミングによっては依存しているパッケージの別のバージョンが入ってしまう。
なんてったって、go get にはバージョンを指定しないのだから、何が落ちてきてるのかわからん。
Goの思想としては常に最新バージョン使おうぜ、ということらしいが、 そのことと、メンバー間の環境の同期はまた別の話だよね。

別のプロジェクトでも使ってる問題 Goのプロジェクトとして、AとBがあって、両方でパッケージKを使ってるとする。
「AではK:ver1.1.2を使って、BではK:ver1.1.3を使う」 ということはできない。
GOPATHをそれぞれで設定しておいて、いじるときにいちいち切り替えれば出来るんだろうけど、 基本的にはGOPATHは一個だけ設定するのが良いとされているので、AとBは同じバージョンのKを参照せざるを得なくなる。
これは辛い。。

Godep そこで登場するのがプロジェクト毎に依存関係を指定、管理できるツール、Godep。
安心のGithub製。
そのプロジェクトで使っているパッケージとバージョン(正確にはコミットsha)を
godep save ./...  で記録(その時点のスナップショット的な感じ)できる。
新しく Godeps と Gedeps/_workspace というディレクトリと、Godep.</description>
    </item>
    
    <item>
      <title>これからGoやる人のためのGOPATH</title>
      <link>https://takecy.github.io/posts/golang-env-gopath/</link>
      <pubDate>Wed, 05 Aug 2015 00:52:24 +0900</pubDate>
      
      <guid>https://takecy.github.io/posts/golang-env-gopath/</guid>
      <description>Goはじめて3ヶ月。
Goいいな、Goクソだなと日々葛藤。
Goをこれからはじめようという人が迷いそうな(俺が迷った)GOPATH について。

Goのインストール インストール自体はbrewで速攻終わる。
$ brew install go  問題はこの後の$GOPATHの設定。

GOPATHって何 http://golang-jp.org/doc/code.html#GOPATH &amp;gt;GOPATH環境変数はワークスペースの場所を示してします。
そのままなのだが、つまり、
1. Goを書くのは全部このパス下でやってね
2. Go書く上で依存してるライブラリのソースも全部このパスに入るよ
ということで、例にあるようにそのまま、
$ export GOPATH=$HOME/go $ export PATH=$PATH:$GOPATH/bin  としているが、特に困っていない。

Goを書く じゃGo書くぜってことになるが、GOPATH直下に書くわけではない というのがめんどくさいところ。
まず、Goを書く時は、Githubに公開する前提 と考えておいたほうがよい。 というのも、Goを書いていると頻出するが、外部ライブラリの import文はほぼ、GithubのURLになる。
import &amp;quot;fmt&amp;quot; // 標準パッケージ import &amp;quot;github.com/takecy/hoge&amp;quot; // OSSのライブラリ  github.com/{account_name}/{repository_name} でimportできるステキ仕様。 そしてライブラリのメソッドとか呼び出すためには、ソースコードを取得しないといけないので、下記を実行する。
$ go get github.com/takecy/hoge  ここで、GOPATH が登場する。
このライブラリがダウンロードされ、配置されるパスは $GOPATH/src/github.com/takecy/hoge
になる。
自分のGoのプロジェクトもこれと同じように、 $GOPATH/src/github.com/{account_name}/{repository_name}
ディレクトリを作って、そこにGoソースを作成してスタートする。
Githubで公開する気とか無いし、、と思っても、このパスで作るのがおすすめ。

まとめ Goやり始めた当初は、元々$HOME/git下に全部Github関連入れていたので、移動したくなく、GOPATHにシンボリックリンク貼ったりとかして抵抗していたのだが、結局Go関連は、全部移動することに。。
同じGithubからのソースなのに、全然別のディレクトリになっているもやもやは地味にストレス。</description>
    </item>
    
  </channel>
</rss>